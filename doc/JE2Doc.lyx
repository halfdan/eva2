#LyX 1.4.1 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass amsbook
\begin_preamble
\usepackage{listings}
\usepackage{url}
\usepackage{a4wide}

%\declare@shorthand{english}{""}{\hskip\z@skip}
\newcommand{\origttfamily}{}% sollte noch nicht definiert sein!
\let\origttfamily=\ttfamily % alte Definition von \ttfamily sichern
\renewcommand{\ttfamily}{\origttfamily \hyphenchar\font=`\-}
\end_preamble
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Title
JavaEvA 2 Short Documentation
\end_layout

\begin_layout Author
Marcel Kronfeld
\end_layout

\begin_layout Address
Dept.
 of Computer Architecture, 
\end_layout

\begin_layout Address
Prof.
 Dr.
 Andreas Zell, 
\end_layout

\begin_layout Address
University of Tübingen
\end_layout

\begin_layout Thanks
We like to thank all former and current developers of 
\noun on
JavaEvA
\noun default
 (Jürgen Wakunda, Holger Ulmer, Felix Streichert, and Hannes Planatscher)
 and all the students involved in the developement.
\end_layout

\begin_layout URL
http://www.ra.cs.uni-tuebingen.de/software/JavaEvA
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \tableofcontents{}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
hyphenation{Run-nable javaaddpath}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Standard

\backslash
hyphenation{Ab-stract-Op-ti-mi-za-tion-Prob-lem Ab-stract-Prob-lem-Double
 Ab-stract-Prob-lem-Bi-na-ry javaeva.server.go.problems}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard

\emph on
\noun on
JavaEvA 2
\emph default
\noun default
 (a 
\bar under
Java
\bar default
 implementation of 
\bar under
Ev
\bar default
olutionary 
\bar under
A
\bar default
lgorithms, revised version 
\bar under
2
\bar default
) is a comprehensive heuristic optimization framework with emphasis on Evolution
ary Algorithms.
 It is a revised version of the 
\noun on
JavaEvA
\noun default
 
\begin_inset LatexCommand \cite{JOptDocumentation}

\end_inset

 optimization toolbox, which has been developed as a resumption of the former
 
\noun on
EvA
\noun default
 software package 
\begin_inset LatexCommand \cite{Wakunda97EvA}

\end_inset

.
\end_layout

\begin_layout Standard

\noun on
JavaEvA 2
\noun default
 integrates several derivation free optimization methods, preferably population
 based, such as Evolution Strategies, Genetic Algorithms, Differential Evolution
, Particle Swarm Optimization, as well as classical techniques such as multi-sta
rt Hill Climbing or Simulated Annealing.
\end_layout

\begin_layout Standard

\noun on
JavaEvA 2
\noun default
 aims at two groups of users.
 Firstly, the standard user who does not know much about the theory of Evolution
ary Algorithms, but wants to use Evolutionary Algorithms to solve an application
 problem.
 Secondly, the experienced programmer who wants to investigate the performance
 of different optimization algorithms or wants to compare the effect of
 alternative or specialized evolutionary or heuristic operators.
 The latter usually knows more about Evolutionary Algorithms or heuristic
 optimization and is able to extend 
\noun on
JavaEvA 2
\noun default
 by adding specific optimization strategies or solution representations.
\end_layout

\begin_layout Standard
This document is, as the title says, not an extensive manual on the 
\noun on
JavaEvA 2
\noun default
 framework, but instead a short introduction hoping to ease access to 
\noun on
JavaEvA 2.

\noun default
 Thus, the document is mainly oriented by use-cases and tries to deliver
 knowledge on a top-down basis, with most important things first and details
 where required.
 Still, as 
\noun on
JavaEvA
\noun default
 just as heuristic optimization itself can become tricky sometimes, it is
 not always possible to explain things without cross-references.
 We hope that this document will, anyways, be a valuable helper in working
 with 
\noun on
JavaEvA 2
\noun default
.
\end_layout

\begin_layout Standard
Main topics will be, of course, a Quick Start guide (Sec.
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{sec:Quick-Start}

\end_inset

), a guide to the GUI (Sec.
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{sub:Quickly-Using-GUI}

\end_inset

) and basics on the Java programming interface (Sec.
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{sec:Using-the-API}

\end_inset

), but also some words on how to use JavaEvA 2 with external programs such
 as Matlab (Sec.
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{sec:External-Interfaces}

\end_inset

).
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Quick Start
\begin_inset LatexCommand \label{sec:Quick-Start}

\end_inset


\end_layout

\begin_layout Standard
The following sections give a short introduction in the main aspects of
 using
\noun on
 Ja
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
-
\end_layout

\end_inset

va
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
-
\end_layout

\end_inset

EvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
-
\end_layout

\end_inset

2
\noun default
, explaining the possibilities accessible by the GUI.
 Even if you want to use the API without the GUI, we recommend to try some
 optimization runs through the GUI first, as it will help to learn about
 the concepts used in the framework.
\end_layout

\begin_layout Subsection
Running 
\noun on
JavaEvA
\noun default

\begin_inset LatexCommand \label{sub:Quickly-Running-JavaEvA}

\end_inset


\end_layout

\begin_layout Standard
To quickly test
\noun on
 JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
, we recommend you download the jar-package 
\emph on
JE2Base.jar
\emph default
 and start the GUI.
 The jar-file can be downloaded from the 
\noun on
Ja
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
-
\end_layout

\end_inset

va
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
-
\end_layout

\end_inset

EvA
\noun default
 homepage
\begin_inset Foot
status open

\begin_layout Standard
http://www.ra.cs.uni-tuebingen.de/software/JavaEvA/
\end_layout

\end_inset

 
\begin_inset LatexCommand \cite{JE2HomePage}

\end_inset

.
\end_layout

\begin_layout Standard
To start under GNU/Linux, you can just type:
\end_layout

\begin_layout Quotation

\family typewriter
\size small
$ java -cp JE2Base.jar javaeva.client.EvAClient
\end_layout

\begin_layout Standard
Note that 
\begin_inset Quotes eld
\end_inset


\family typewriter
$
\family default

\begin_inset Quotes erd
\end_inset

 stands for the command prompt, which needs not to be typed.
 In the same or a similar way, you can start it on all other platforms that
 support Java
\noun on
.

\noun default
 For technical reasons, we discourage using the Java option 
\emph on
-jar
\emph default
 with 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
.
\end_layout

\begin_layout Standard
If you want to work on the source code directly, note that it is also vital
 to copy the resource folder to the location where the compiled class files
 are located.
 You can then again start the GUI or optimize through the API (Sec.
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{sec:Using-the-API}

\end_inset

).
 However we advise you to learn to know the GUI a little before digging
 in the source code.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Using the GUI
\begin_inset LatexCommand \label{sub:Quickly-Using-GUI}

\end_inset


\end_layout

\begin_layout Standard
From the GUI, also called the 
\noun on
JavaEvA
\noun default
 workbench, all important components of an optimization run can be accessed
 and configured.
 To change the optimization method, for example, click on the field labeled
 with 
\begin_inset Quotes eld
\end_inset


\emph on
optimizer
\emph default

\begin_inset Quotes erd
\end_inset

 and select the desired algorithm from the drop-down menu.
 Basically, you thereby select a Java class and create an instance, whose
 public properties are displayed in the window immediately with their standard
 values.
 For your optimization run, you may configure the parameter values directly
 through the input fields.
 A short description will be displayed by tip-text over the name of each
 parameter.
 We will now shortly summarize the components of the workbench (Fig.
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{fig:Screenshots-workbench}

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename /afs/cs.uni-tuebingen.de/home/mkron/workspace/JE2Base/doc/pics/screenshot-workbench.jpg
	lyxscale 60
	width 48text%

\end_inset

\InsetSpace ~
\InsetSpace ~

\begin_inset Graphics
	filename /afs/cs.uni-tuebingen.de/home/mkron/workspace/JE2Base/doc/pics/screenshot-workbench-stats.jpg
	lyxscale 60
	width 48text%

\end_inset


\end_layout

\begin_layout Caption
Screenshots of the workbench window, with optimization (left) and statistics
 (right) parameters.
\begin_inset LatexCommand \label{fig:Screenshots-workbench}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The Workbench Window
\begin_inset LatexCommand \label{sub:The-Workbench-Window}

\end_inset


\end_layout

\begin_layout Standard
The optimization parameters:
\end_layout

\begin_layout Description

\shape italic
Optimizer
\shape default
 Select the main optimization method.
 You can choose between classical as well as evolutionary and swarm-based
 optimization methods.
 For quick optimization, just use the standard values of the parameters
 and try several different optimizers.
\end_layout

\begin_layout Description

\shape italic
Post-processing
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset

parameters
\shape default
 In some cases, post processing of the results is desirable, e.g.
 if you want to improve the single found solution by small hill climbing
 steps, or if you want to retrieve more than one solution from a clustering
 optimization approach.
\end_layout

\begin_layout Description

\shape italic
Problem 
\shape default
The instance of the target function to be optimized is specified here.
 You can select from the benchmark problems delivered with the package or
 inherit from the problem class yourself (Sec.
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{sec:Using-the-API}

\end_inset

).
\end_layout

\begin_layout Description

\shape italic
Random
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

Seed
\shape default
 As most algorithms in 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
 incorporate stochastic components, the random seed is critical for the
 specific outcome of a run.
 For replicable results, set a seed value > 0.
 To receive statistically relevant results, test several times with a seed
 of 0, which means that the system time is used as seed for each new run,
 or use the multi-run option.
\end_layout

\begin_layout Description

\shape italic
Termination
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

Criterion 
\shape default
Set the criterion by which to stop an optimization run, e.g.
 stop after 
\emph on
n
\emph default
 fitness evaluations.
\end_layout

\begin_layout Standard
The Statistics parameters:
\end_layout

\begin_layout Description

\shape italic
Convergence
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

Rate
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

Threshold
\shape default
 Provided the target value is zero, convergence is assumed if a value smaller
 than this threshold is reached.
 For multi-run experiments, the number of hits is counted using this criterion.
\end_layout

\begin_layout Description

\shape italic
Number
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

of
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

Multi-runs
\shape default
 To achieve statistically meaningful results on how well a certain optimizer
 works on a given problem, set this number to do several runs in a row.
 The plot will be averaged, while all intermediate data can be collected
 in an output file or text window.
\end_layout

\begin_layout Description

\shape italic
Fitness
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

to
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

Plot 
\shape default
Define which fitness values to be displayed in the plot window after every
 generation.
 Select 
\begin_inset Quotes eld
\end_inset

best
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

worst
\begin_inset Quotes erd
\end_inset

 or both.
\end_layout

\begin_layout Description

\shape italic
Result
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

File
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

Name 
\shape default
If you want to collect optimization data, set this string to a desired file
 name.
 Optimization results will be written to the indicated file in the working
 directory.
\end_layout

\begin_layout Description

\shape italic
Show
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

Text
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

Output 
\shape default
If activated, the optimization data will also be shown in a graphical text
 window for immediate inspection.
\end_layout

\begin_layout Standard
Finally, there are three buttons on top.
 
\emph on

\begin_inset Quotes eld
\end_inset

Description
\emph default

\begin_inset Quotes erd
\end_inset

 shows some very general information on the main 
\noun on
JavaEvA
\noun default
 module.
 The 
\begin_inset Quotes eld
\end_inset


\emph on
Start Optimization
\emph default

\begin_inset Quotes erd
\end_inset

 button, as expected, starts an optimization run using the parameters set,
 or multiple runs sequentially if 
\emph on
multiRuns
\emph default
 is set higher than one.
 During optimization, the 
\begin_inset Quotes eld
\end_inset


\emph on
Stop
\emph default

\begin_inset Quotes erd
\end_inset

 button can abort the (multi-)run.
\end_layout

\begin_layout Subsubsection
The Plot Window
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename /afs/cs.uni-tuebingen.de/home/mkron/workspace/JE2Base/doc/pics/screenshot-plot-window.jpg
	lyxscale 60
	width 55text%

\end_inset


\end_layout

\begin_layout Caption
Plot window comparing a simple (5,20)-ES and PSO on Rastrigin's after 10
 runs each.
\begin_inset LatexCommand \label{fig:The-plot-window}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
During the optimization run, the progress of the solution is plottet to
 a graph in a separate window (Fig.
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{fig:The-plot-window}

\end_inset

).
 Usually, the fitness of the best individual of every generation is drawn
 in Y-direction along the number of function calls in X-direction.
 Be aware that for multi-objective problems, only the first fitness dimension
 is shown.
 The 2-dimensional multi-objective problem classes have, however, a pareto-front
 viewer which displays the population in the two fitness dimensions sequentially.
 For higher fitness dimensions it is more practical to use external tools
 for visualization.
 Figure
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{fig:The-plot-window}

\end_inset

, by the way, shows the fitness progress averaged over 10 runs of a (5,20)-ES
 and a PSO strategy on Rastrigin's Problem: PSO converges slower, but finds
 better results on the long run, while ES settles earlier on higher plateaus.
 
\end_layout

\begin_layout Standard
The visible buttons have the following functions:
\end_layout

\begin_layout Description

\emph on
Clear
\emph default
 Remove all graphs from the plot window.
\end_layout

\begin_layout Description

\shape italic
Log/Lin
\shape default
 Switch between linear and log-scaled view.
 Most benchmark problems in 
\noun on
JavaEvA
\noun default
 are implemented with the minimum fitness at zero, so that the log-scale
 view allows to compare and analyze convergence behaviour in detail.
 Of course, if the target fitness may become zero or negative, log-scale
 view is impossible.
\end_layout

\begin_layout Description

\shape italic
Dump
\shape default
 Export the contained data to standard output.
 For each graph, a column is created in the same order they were generated.
\end_layout

\begin_layout Description

\shape italic
Export
\shape default
 Create the same output as 
\shape italic
Dump
\shape default
 and save it to a file.
\end_layout

\begin_layout Description

\shape italic
Save
\shape default
\noun on

\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset


\shape italic
\noun default
as
\shape default
\noun on

\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset


\shape italic
\noun default
JPG
\shape default
 Create a JPEG image of the plot window and save it to a file.
\end_layout

\begin_layout Subsubsection
Some Words on the Words
\end_layout

\begin_layout Standard
As 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
 is mainly about Evolutionary and Heuristic Optimization, some of the terms
 and notions are borrowed from the area and used in this document.
 As they may not be familiar to all who want to use the framework, we give
 a short summary here.
\end_layout

\begin_layout Standard
We aim at optimizing a target function without knowing much about it, and
 find a certain position in the search space which minimizes the function,
 called the 
\emph on
solution
\emph default
.
 During search, we use a specific search strategy, the 
\emph on
optimizer
\emph default
, which usually looks at several positions in parallel.
 Those are all 
\emph on
potential solutions
\emph default
, because we don't know the real one yet.
 For the potential solutions we evaluate the target function.
 The value received is often called 
\emph on
fitness
\emph default
 in analogy to Darwin's Theory of Evolution, where 
\begin_inset Quotes eld
\end_inset

the fitter ones survive
\begin_inset Quotes erd
\end_inset

.
 For the same reason, potential solutions are sometimes called 
\emph on
individuals
\emph default
, and the set of potential solutions stored by the optimizer at a time may
 be called 
\emph on
the
\emph default
 
\emph on
population
\emph default
.
 Many of the implemented optimization strategies employ operators in analogy
 to natural 
\emph on
mutation
\emph default
, 
\emph on
crossover
\emph default
 and 
\emph on
selection
\emph default
.
 
\end_layout

\begin_layout Standard
There is nothing mystical about that, and of course the analogy is often
 exaggerated.
 Evolutionary Optimization is an algorithmic tool that serves mostly technical
 purposes.
 That it works is by no means a sign that we fully understand natural evolution
 or can even proof anything about it.
 This said, however, we should also note that noone today should really
 doubt that evolution works.
\end_layout

\begin_layout Standard
This document will not explain in detail how the implemented optimizers
 work, as there is enough literature out there handling these topics.
 We refer to Sec.
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{sec:Further-Reading}

\end_inset

 for suggestions on further reading.
\end_layout

\begin_layout Subsubsection
Basic Optimization using 
\noun on
JavaEvA 2
\noun default

\begin_inset LatexCommand \label{sub:Basic-Optimization-GUI}

\end_inset


\end_layout

\begin_layout Standard
To get a grip on 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
 and what optimization means, it is best to run some experiments on the
 implemented standard benchmarks.
 To do that, start the GUI and select a benchmark problem, e.g.
 the F1-Problem consisting in a simple hyper-parabola.
 Leave the post-processing deactivated.
 Then choose an optimizer, such as Evolution Strategies with standard parameters
, set the termination criterion to EvaluationTerminator with 10,000 fitness
 calls and push the 
\begin_inset Quotes eld
\end_inset

Start Optimization
\begin_inset Quotes erd
\end_inset

 button at the top of the window.
 Two additional windows will now open up: the plot window with a fitness
 graph, and a text box displaying the optimization progess in textual form.
 The final result will be printed into the text box at the end of the run,
 as well.
\end_layout

\begin_layout Standard
If you play around with some optimizer settings, e.g.
 you try different values for 
\begin_inset Formula $\mu$
\end_inset

 and 
\begin_inset Formula $\lambda$
\end_inset

 or activate the plusStrategy checkbox, you will notice changing performance
 of the ES.
 On problems with in discrete space, such as the B1-benchmark problem, for
 example, a Genetic Algorithm is often superior to an Evolution Strategy.
 You can try this if you clear the plot window, select the B1-problem and
 run the ES a few times.
 Now, switch to the Genetic Algorithm and run the optimization a few more
 times.
\end_layout

\begin_layout Standard
Notice, however, that by changing from the F1-problem to the B1-problem,
 the internal representation of individuals may change.
 As B1 is a typical binary problem, it uses GAIndividuals by default, which
 are based on binary vectors, while F1 uses double vectors.
 Be aware, that not all optimizers in 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
 are built to work on all types of indviduals.
\end_layout

\begin_layout Subsubsection
Post-Processing
\begin_inset LatexCommand \label{sub:Post-Processing}

\end_inset


\end_layout

\begin_layout Standard
To see how post processing works, you can select the 
\emph on
FM0Problem
\emph default
 from the problem list, which is a simple target function with a global
 and a local optimum.
 Select the 
\emph on
ClusterBasedNiching
\emph default
 algorithm as the optimizer.
 Now click on the 
\emph on
postProcessingParams
\emph default
 and activate them.
 For a clustering distance of 
\begin_inset Formula $\sigma=0.1$
\end_inset

 and 
\begin_inset Formula $\approx5,000$
\end_inset

 hill climbing steps, the optimizer should print out just a few solutions
 in the text box, the first of which hopefully are the optima near (1.7/0)
 and (-1.44/0).
\end_layout

\begin_layout Standard
Post-processing serves mainly two purposes: filter redundant solutions and
 refine the search results.
 Redundant solutions occur naturally in population-based heuristics.
 The optimizer handles several potential solutions in parallel, and it is
 hoped that they all converge on the global optimum during the run.
 Or for multi-modal problems which have several local optima, it can be
 desirable to have parts of the population converge in different areas of
 the solution space.
 In any case, one usually wants to retrieve 
\emph on
the
\emph default
 solution set or a refined global optimum.
 For this purpose, we employ a clustering approach which takes the whole
 solution set and merges similar solutions to an associated subset.
 For each of these bulks, only the best individual is returned in the filtered
 solution set.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename /afs/cs.uni-tuebingen.de/home/mkron/workspace/JE2Base/doc/pics/cluster-graph.eps
	lyxscale 50
	width 80col%

\end_inset


\end_layout

\begin_layout Caption
Examples for density based clustering (Streichert et al.
 
\begin_inset LatexCommand \cite{streichertClustering03}

\end_inset

).
\begin_inset LatexCommand \label{fig:Density-based-clustering.}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of course the size of this filtered set depends on the degree of convergence
 in the original set and on the clustering criterion.
 We employ density based clustering 
\begin_inset LatexCommand \cite{ester96density}

\end_inset

, which associates any two individuals which have a distance of less than
 the clustering parameter 
\begin_inset Formula $\sigma$
\end_inset

 (Fig.
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{fig:Density-based-clustering.}

\end_inset

).
 This is an intuitive approach that does not require a predefined number
 of clusters, in contrast to k-means, for example.
 By defining 
\begin_inset Formula $\sigma$
\end_inset

, you thus define the resolution you grant your solution set.
\end_layout

\begin_layout Standard
As the solution set always contains the last state of the heuristic optimization
, one may hope that it is converged.
 But of course often it is not fully converged, or maybe the strategy even
 rediversifies the population from time to time, meaning that some part
 of the set it is converged while other individuals are freshly initialized
 and thus by no means optimal.
 So after filtering out redundancy, you might also want to refine the returned
 set a little.
 This can be done directly by Hill Climbing (HC) in the post-processing
 step by setting 
\emph on
postProcessSteps
\emph default
 to the number of evaluation calls you want to invest in the refinement.
\begin_inset Note Comment
status open

\begin_layout Standard
Question here: wft is a hill climber?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you set 
\begin_inset Formula $\sigma$
\end_inset

 for clustering and performed hill climbing, then there will be another
 clustering step right after the HC process, to remove redundancy that emerged
 by the additional HC optimization.
\end_layout

\begin_layout Subsection
Additional Packages
\end_layout

\begin_layout Standard
To add additional packages to use them with the 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
 base package, you can just add them to the class path.
 For instance, to use the additional JE2Probs package containing a larger
 set of benchmark problems, place them both in your working directory and
 type (GNU/Linux):
\end_layout

\begin_layout Quotation

\family typewriter
\size small
$ java -cp JE2Base.jar:JE2Probs.jar javaeva.client.EvAClient
\end_layout

\begin_layout Standard
You should now be able to select from a larger set of optimization problems
 in the GUI.
 Note that different platforms use different characters as path separators
 (':' in GNU/Linux).
 To add your own classes to the 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
 framework (see Sec.
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{sec:Quickly-Adding-Your-Problem}

\end_inset

), you need to add your local development path to the classpath, for example:
\end_layout

\begin_layout Quotation

\family typewriter
\size small
$ java -cp JE2Base.jar:JE2Probs.jar:/home/username/workspace 
\backslash

\end_layout

\begin_layout Quotation

\family typewriter
\size small
javaeva.client.EvAClient
\end_layout

\begin_layout Standard
Note that 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
 will search all classpath entries for compatible classes, so you should
 only add those packages which are really required.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
External Interfaces
\begin_inset LatexCommand \label{sec:External-Interfaces}

\end_inset


\end_layout

\begin_layout Subsection
Optimizing Through an External Command
\begin_inset LatexCommand \label{sub:Optimizing-external-cmd}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename /afs/cs.uni-tuebingen.de/home/mkron/workspace/JE2Base/doc/pics/screenshot-ExtRun.jpg
	width 40col%

\end_inset


\end_layout

\begin_layout Caption
Screenshot of an external runtime problem configuration.
\begin_inset LatexCommand \label{fig:Screenshot-external-runtime}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For easy optimization using a runnable program, we provide the 
\family typewriter
ExternalRuntimeProblem
\family default
 class.
 So if you have a runnable function implementation called 
\begin_inset Quotes eld
\end_inset


\emph on
testEval
\emph default

\begin_inset Quotes erd
\end_inset

 (or 
\begin_inset Quotes eld
\end_inset


\emph on
testEval.exe
\emph default

\begin_inset Quotes erd
\end_inset

), that takes a series of double valued arguments and produces a result
 value as output (on 
\shape italic
stdout
\shape default
), you can select 
\family typewriter
ExternalRuntimeProblem
\family default
 in the GUI, enter the path and program name into the command field, adapt
 boundaries and the problem dimension and just start optimization.
 For a programm called 
\shape italic
testEval
\shape default
 with a two-dimensional solution space, which you want to optimize within
 
\begin_inset Formula $[-5,10]^{2}$
\end_inset

, the configuration can be seen in Fig.
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{fig:Screenshot-external-runtime}

\end_inset

.
 In the example, 
\shape italic
testEval
\shape default
 may be called and, in the single objective case, should produce output
 as in:
\end_layout

\begin_layout Quotation
\align left

\family typewriter
$ /home/username/testEval 7.1642923 -4.2346211
\end_layout

\begin_layout Quotation
\align left

\family typewriter
28.1371802
\end_layout

\begin_layout Quotation
\align left

\family typewriter
$ _
\end_layout

\begin_layout Standard

\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
 starts a system process to run the external program and converts input/output
 using String objects, which is of course rather slow.
 Still, it may sometimes outweigh the costs of reimplementing it anew in
 Java, or come in handy if you just want to test what 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
 might do for you.
\end_layout

\begin_layout Subsection
Optimization from Matlab
\begin_inset LatexCommand \label{sub:Optimization-from-Matlab}

\end_inset


\end_layout

\begin_layout Subsubsection
Quick Howto
\begin_inset LatexCommand \label{sub:JEInterface-Quick-Intro}

\end_inset


\end_layout

\begin_layout Standard
To tackle optimization problems already existing in Matlab, we provide a
 simple Matlab interface comprising in a Matlab class definition.
 If you have an existing Matlab function you want to optimize with some
 standard algorithms implemented in 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
, you can do this now directly from your Matlab console.
 To do so, follow these steps:
\end_layout

\begin_layout Enumerate
Download the JE2Base.jar and add it to the Matlab classpath, e.g.
 by typing 
\family typewriter
javaaddpath /home/username/JE2Base.jar
\family default
 in the Matlab console.
\end_layout

\begin_layout Enumerate
Download the Matlab JEInterface code and extract it to your Matlab working
 directory within its own class directory 
\begin_inset Quotes eld
\end_inset

@JEInterface
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Enumerate
Define the range of your search space using a 
\begin_inset Formula $2\times d$
\end_inset

 matrix consisting of the lower and upper bounds of the allowed space, e.g.
 enter 
\family typewriter
R=[[-5 -5 -5];[5 5 5]]
\family default
 to define a 3-dimensional search space with bounds -5/5 in every dimension.
\end_layout

\begin_layout Enumerate
For a target function 
\emph on
fun
\emph default
 to be minimized, create a JEInterface in Matlab by typing, for example:
 
\family typewriter
JI=JEInterface('JI', @fun, R)
\family default
.
 Notice that 
\emph on
fun
\emph default
 must be accessible from your working directory, it should not be placed
 in the @JEInterface directory.
\end_layout

\begin_layout Enumerate
To view the possible optimization strategies, type 
\family typewriter
showOptimizers(JI)
\family default
.
\end_layout

\begin_layout Enumerate
You can now select an optimizer and use its ID to start the optimization,
 e.g.
 
\family typewriter
JI=op
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
-
\end_layout

\end_inset

ti
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
-
\end_layout

\end_inset

mize
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
-
\end_layout

\end_inset

(JI,1)
\family default
 for a standard ES.
\end_layout

\begin_layout Enumerate
Wait for the optimization to finish and type 
\family typewriter
getResult(JI)
\family default
 to get the best solution found.
\end_layout

\begin_layout Subsubsection
Details on JEInterface
\end_layout

\begin_layout Standard
As Matlab is single-threaded and Java needs to call it back to calculate
 function values, the 
\family typewriter
optimize
\family default
 command starts a new Java thread and returns directly to Matlab.
 This means that the optimization works asynchronously: the result will
 be written to the JEInterface instance and is not a direct output value
 of the 
\family typewriter
optimize
\family default
 call.
 There will be a text notice in the Matlab console as soon as the optimization
 has finished.
 Notice that in Matlab object oriented style, an object 
\family typewriter
Obj
\family default
 cannot be modified simply by calling the mutator, e.g.
 
\family typewriter
setParameter(Obj, p1, val1)
\family default
, but must be reassigned for every mutating call, as in: 
\family typewriter
Obj=setParameter(Obj, p1, val1)
\family default
.
\end_layout

\begin_layout Standard
Because of that, the JEInterface method 
\family typewriter
isFinished
\family default
, which checks the state of a JEInterface object, (i.e., optimization finished
 or not), only works correctly if you start the optimization with assignment
 (as described in Section 
\begin_inset LatexCommand \ref{sub:JEInterface-Quick-Intro}

\end_inset

).
 After optimization, you may retrieve the result by calling 
\family typewriter
getResult
\family default
 on the interface instance.
 Or, in case you want to retrieve multiple solutions to the target function,
 you may start a post processing step and retrieve a list of solutions using
 
\family typewriter
getMultipleSolutions
\family default
.
\end_layout

\begin_layout Standard
Some optimizers allow the solutions to get worse during the optimization
 run.
 This allows them to overcome local optima and increases the chance to find
 a global one.
 But on the other hand it means that the result of the last optimization
 iteration is not necessarily the best solution found during the whole run.
 Therefore, 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
 saves the best solution found external to the optimizer, which is what
 is returned by the 
\family typewriter
getResult
\family default
 method.
 
\end_layout

\begin_layout Standard
For further details, check the method overview in the list below.
 Each interface method (except the constructor) has at least a parameter
 
\family typewriter
JI
\family default
, designating the JEInterface object to work on.
\end_layout

\begin_layout Description

\family typewriter
JI=JEInterface(interfaceName,fhandle,range[,optset,fargs])
\family default
 JEInterface constructor: 
\emph on
interfaceName
\emph default
: the name bound to the JEInterface in Matlab as char.
 
\emph on
fhandle
\emph default
: handle of the target function.
 
\emph on
range
\emph default
: a 2
\begin_inset Formula $\times$
\end_inset

dim array defining the solution subspace with lower and upper bounds.
 
\emph on
optset
\emph default
: an (optional) 
\emph on
optimset
\emph default
 structure of which 
\emph on
MaxFunCalls
\emph default
, 
\emph on
TolX
\emph default
 and 
\emph on
TolFun
\emph default
 are used as termination criteria, while 
\emph on
Display
\emph default
 may trigger verbose output.
 
\emph on
fargs
\emph default
: (optional) additional static parameters to the target function as single
 list.
 Returns the new JEInterface instance.
\end_layout

\begin_layout Description

\family typewriter
showOptimizers(JI)
\family default
 Print a list of optimization strategies accessible through JEInterface
 by ID numbers.
\end_layout

\begin_layout Description

\family typewriter
JI=optimize(JI,optType[,resultFilePrefix])
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
Start the optimization using the strategy indicated by the ID 
\emph on
optType
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
.
 Optionally write verbose results to an output file with prefix 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\noun default
resultFilePrefix
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
 in the working directory.
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
Returns the modified JEInterface instance.
\end_layout

\begin_layout Description

\family typewriter
isFinished(JI)
\family default
 Check whether an optimization process is currently running (return value
 0).
 Returns 1 before and after an optimization run.
\end_layout

\begin_layout Description

\family typewriter
getProgress(JI)
\family default
 During optimization, return the number of fitness calls performed until
 now.
\end_layout

\begin_layout Description

\family typewriter
[sol,fit]=getResult(JI)
\family default
 After optimization: return the final solution and its fitness.
 During optimization: return the current best solution and its fitness.
\end_layout

\begin_layout Description

\family typewriter
getMessage(JI)
\family default
 Return a text message describing the termination state of the optimization,
 e.g.
 the number of function calls performed.
\end_layout

\begin_layout Description

\family typewriter
JI=stopOptimize(JI)
\family default
 Stop a running optimization process.
 An intermediate result will be written back to the interface instance from
 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
.
\end_layout

\begin_layout Description

\family typewriter
JI=postProcess(JI,steps,sigmaClust[,nBest])
\family default
 Do post-processing of the last optimization results and export the solution
 set to the interface instance (cf.
 Sec.
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{sub:Post-Processing}

\end_inset

).
 If 
\emph on
sigmaClust
\emph default
 > 0 a clustering step is performed (density based clustering), so that
 any solutions in a distance below 
\emph on
sigmaClust
\emph default
 are associated.
 Notice that 
\emph on
sigmaClust
\emph default
 is treated relative to the problem range.
 If 
\emph on
steps
\emph default
 > 0, then a hill climbing step is performed after clustering for the given
 number of evaluations.
 If 
\emph on
nBest
\emph default
 is given, it defines the maximal number of solutions to be exported to
 the interface instance.
 Post processing can be stopped by 
\family typewriter
JI=stopOptimize(JI)
\family default
 just as the optimization itself.
\end_layout

\begin_layout Description

\family typewriter
[sols,fits]=getMultipleResults(JI)
\family default
 If a post processing step has been performed: retrieve the solution set
 in a matrix and calculate the corresponding fitness values.
\end_layout

\begin_layout Description

\family typewriter
getOptions(JI)
\family default
 Get the current 
\emph on
optimset
\emph default
 structure of the JEInterface instance.
\end_layout

\begin_layout Description

\family typewriter
getOpt(JI,optName)
\family default
 Get the value of a specific option 
\emph on
optName
\emph default
 from the 
\emph on
optimset
\emph default
 structure of the JEInterface instance.
\end_layout

\begin_layout Description

\family typewriter
JI=setOpt(JI,optName,optVal)
\family default
 Set a specific option 
\emph on
optName
\emph default
 of the 
\emph on
optimset
\emph default
 structure in 
\family typewriter
JI
\family default
 to the value 
\emph on
optVal
\emph default
.
 Returns the modified JEInterface instance.
\end_layout

\begin_layout Description

\family typewriter
JI=setOptions(JI,optset)
\family default
 Set a whole new 
\emph on
optimset
\emph default
 structure 
\emph on
optset
\emph default
.
 Returns the modified JEInterface instance.
\end_layout

\begin_layout Description

\family typewriter
setResultJE
\family default
 Write-back method required internally by 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
.
 Calling it by hand may interfere with optimization.
\end_layout

\begin_layout Description

\family typewriter
setResultArrayJE
\family default
 Write-back method required internally by 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
.
 Calling it by hand may interfere with optimization.
\end_layout

\begin_layout Description

\family typewriter
evaluateJE
\family default
 Evaluation method required internally by 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2.

\noun default
 Calling it by hand may interfere with optimization.
\end_layout

\begin_layout Standard
The methods are listed in about the order a user might require them in.
 The constructor as well as all mutating methods return a JEInterface object
 which is to be assigned to a variable, preferably the same as the one assigned
 on construction.
 This is a drawback of the Matlab object concept: mutators are actually
 also constructors and copy the whole Matlab object, but they do not copy
 the referenced Java instance.
 
\end_layout

\begin_layout Standard
Notice that the last three methods, 
\family typewriter
setResultJE
\family default
, 
\family typewriter
setResultArrayJE
\family default
 and 
\family typewriter
evaluateJE
\family default
, are used internally by the Java part of the interface and should not be
 called by hand.
 To find out more about the optimization strategies you can access through
 JEInterface, use the 
\family typewriter
showOptimizers
\family default
 method and take a look at the EA references, e.g.
 the technical report on 
\noun on
JavaEvA
\noun default
 
\begin_inset LatexCommand \cite{JOptDocumentation}

\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Optimization Options
\end_layout

\begin_layout Standard
Vital for the usage in Matlab are the termination criteria of the optimization
 run.
 We adopt the builtin 
\emph on
optimset
\emph default
 structure in analogy to the Matlab function 
\emph on
fminsearch,
\emph default
 using the three parameters described in the list below.
 To find out more about 
\emph on
optimset
\emph default
, check the Matlab documentation.
\end_layout

\begin_layout Description

\emph on
MaxFunEvals
\emph default
 Maximum number of function evaluations allowed.
\end_layout

\begin_layout Description

\emph on
TolX
\emph default
 Convergence tolerance in solution space, measured absolutely.
 This means that the run is seen as converged, if the best individual (the
 best parameter set) does not change more than the given threshold for a
 certain time.
\end_layout

\begin_layout Description

\emph on
TolFun
\emph default
 Convergence tolerance in fitness space, measured absolutely.
 This means that the run is seen as converged, if the best fitness found
 does not change more than this threshold for a certain time.
\end_layout

\begin_layout Description
Display Triggers online output during an optimization process on the Matlab
 console.
 Allowed values are '
\family typewriter
off
\family default
' and '
\family typewriter
iter
\family default
', where for '
\family typewriter
iter
\family default
' an output line is written for every generational step.
 The default is '
\family typewriter
off
\family default
'.
\end_layout

\begin_layout Standard
If no 
\emph on
optimset
\emph default
 struct is given to the constructor, the default values for 
\emph on
TolX
\emph default
 and 
\emph on
TolFun
\emph default
 are the same as in Matlab (
\begin_inset Formula $10^{-4}$
\end_inset

), while the default value for 
\emph on
MaxFunEvals
\emph default
 is usually 
\begin_inset Formula $10^{4}$
\end_inset

.
 You can check the options by calling 
\emph on
getOptions
\emph default
 for a JEInterface instance.
 In analogy to 
\emph on
fminsearch
\emph default
, the three criteria will be logically combined as in 
\begin_inset Formula $(MaxFunEvals\;\mathrm{OR}\;(TolX\;\mathrm{AND}\; TolFun))$
\end_inset

, meaning that reaching 
\emph on
MaxFunEvals
\emph default
 is a hard stopping criterium, while 
\emph on
TolX
\emph default
/
\emph on
TolFun
\emph default
 must be both fulfilled to stop the run, if 
\emph on
MaxFunEvals
\emph default
 has not been reached.
 To change options on an existing object 
\family typewriter
JI
\family default
, call for example 
\family typewriter
JI=setOpt(JI, 'TolFun', 1e-7)
\family default
 to set the TolFun convergence threshold to 
\begin_inset Formula $10^{-7}$
\end_inset

.
 If you don't want to regard convergence and just have the optimization
 perform a certain number of evaluations, set 
\emph on
TolX
\emph default
 and 
\emph on
TolFun
\emph default
 to zero, e.g.
 by typing 
\family typewriter
JI=setOptions(JI, optimset(getOptions(JI), 'TolX', 0, 'TolFun', 0))
\family default
.
 Be aware that at least one termination criterion must be defined through
 the options, or the optimization will not start.
\end_layout

\begin_layout Section
Quickly Adding Your Own Problem Class
\begin_inset LatexCommand \label{sec:Quickly-Adding-Your-Problem}

\end_inset


\end_layout

\begin_layout Standard
It is easy to integrate your own Java-coded problem in 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
 and optimize it using the GUI.
 Preconditions for the quick way are only the two following ones:
\end_layout

\begin_layout Itemize
A potential solution to your problem can be coded as a double vector or
 a BitSet.
\end_layout

\begin_layout Itemize
You can implement the target function such that it produces a double valued
 fitness vector from the double vector or BitSet.
\end_layout

\begin_layout Standard
If these simple conditions are met, you have the advantage of being able
 to use the full 
\begin_inset Quotes eld
\end_inset

Java-Power
\begin_inset Quotes erd
\end_inset

 to implement a target function and optimize it in 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
.
 Just follow these steps:
\end_layout

\begin_layout Itemize
Create an empty class (let's say, 
\family typewriter
ExampleProblem
\family default
) and assign it to the package 
\family typewriter
simpleprobs
\family default
.
 Put it in a directory called 
\begin_inset Quotes eld
\end_inset

simpleprobs
\begin_inset Quotes erd
\end_inset

 within your working directory.
\end_layout

\begin_layout Itemize
Have the class inherit from 
\family typewriter
simpleprobs.SimpleDoubleProblem
\family default
 or 
\family typewriter
simple
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
-
\end_layout

\end_inset

probs.Simple
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
-
\end_layout

\end_inset

Binary
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
-
\end_layout

\end_inset

Problem
\family default
, depending on which datatype you want to use.
 Both base types can be used directly from the 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
 jar-file (which of course needs to be on the java classpath).
\end_layout

\begin_layout Itemize
Implement the method 
\family typewriter
public int getProblemDimension() {...}
\family default
 whithin your ExampleProblem, which returns the number of dimensions of
 the solution space, i.e.
 the length of the 
\emph on
x
\emph default
 vector or size of the 
\family typewriter
BitSet
\family default
, respectively.
 The problem dimension may be a variable defined in your class, but it must
 not change during an optimization run.
\end_layout

\begin_layout Itemize
Implement the method 
\family typewriter
public double[] eval(double[] x)
\family default
 or 
\family typewriter
public double[] eval(
\begin_inset ERT
status open

\begin_layout Standard


\backslash
-
\end_layout

\end_inset

BitSet bs)
\family default
 , respectively, whithin your ExampleProblem, where the fitness of a potential
 solution is calculated.
\end_layout

\begin_layout Itemize
Start the 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
 GUI.
 
\emph on
Make sure that your working directory is in the Java classpath
\emph default
! From the problem list, select the 
\emph on
SimpleProblemWrapper
\emph default
 class as optimization problem.
 The wrapper class allows you to select your ExampleProblem as target function.
 If you implemented a double valued problem, you may also set a default
 range parameter, defining the positive and negative bound of the solution
 space allowed.
 Now select your prefered optimization method and start the optimization.
\end_layout

\begin_layout Section
Using the JavaEvA 2 API
\begin_inset LatexCommand \label{sec:Using-the-API}

\end_inset


\end_layout

\begin_layout Standard
This chapter describes how to incorporate 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
 into existing projects through the Java API.
\end_layout

\begin_layout Subsection
Accessing Standard Optimizers
\begin_inset LatexCommand \label{sub:Accessing-Standard-Optimizers}

\end_inset


\end_layout

\begin_layout Standard
A standard optimizer can be defined as a more or less popular optimization
 algorithm with operators and parameters predefined in a general way so
 that a user may use it out-of-the-box and expect good optimization results
 in general.
 Of course, every expert may have an own notion on what parameters are preferabl
e in general.
 Therefore we give two usage examples using the API.
 In any case, a necessary step is to extend a 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
 base class constituting the target function.
 You may, again, use the simpleprobs package described in 
\begin_inset LatexCommand \ref{sec:Quickly-Adding-Your-Problem}

\end_inset

.
 However, this makes it necessary to use the wrapper class 
\family typewriter
SimpleProblemWrapper
\family default
, which is great for direct GUI usage but may make programming a bit more
 complicated.
 We therefore recommend here to go one step higher in hierarchy and extend
 
\family typewriter
AbstractProblemDouble
\family default
 or 
\family typewriter
AbstractProblemBinary
\family default
.
\end_layout

\begin_layout Subsubsection
The Abstract Problem Classes
\begin_inset LatexCommand \label{sub:The-Abstract-Problem-classes}

\end_inset


\end_layout

\begin_layout Standard
The problem class subtree encapsulates properties of target functions that
 can be directly optimized by the 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
 framework and starts at the 
\family typewriter
AbstractOptimizationProblem
\family default
 class.
 The basic properties of the problem class are functional: 
\end_layout

\begin_layout Enumerate
The problem is itself initialized, 
\end_layout

\begin_layout Enumerate
the problem knows how to initialize a set of potential solutions, and 
\end_layout

\begin_layout Enumerate
the problem evaluates a set of potential solutions.
 
\end_layout

\begin_layout Standard
To implement your own target function in 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
, we recommend inheriting from 
\family typewriter
AbstractProblemDouble
\family default
 or 
\family typewriter
AbstractProblemBinary
\family default
, depending on your preferred data prepresentation.
 Integer and program-data-based problems are currently not covered by this
 document.
\end_layout

\begin_layout Paragraph*
The class 
\family typewriter
AbstractProblemDouble
\end_layout

\begin_layout Standard
The 
\family typewriter
AbstractProblemDouble
\family default
 class in the package 
\family typewriter
java
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
-
\end_layout

\end_inset

eva.ser
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
-
\end_layout

\end_inset

ver.go.prob
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
-
\end_layout

\end_inset

lems
\family default
 encapsulates methods useful to implement double valued target functions.
 Let's assume you want to implement a function 
\begin_inset Formula $f_{\mathrm{target}}(x)=y$
\end_inset

 with 
\begin_inset Formula $f_{\mathrm{target}}:\;\mathbb{R}^{n}\rightarrow\mathbb{R}^{m}$
\end_inset

.
 Important for double-valued problems is the range of the solution space,
 defining in any dimension the minimum and maximum value allowed.
 By setting the 
\family typewriter
default
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
-
\end_layout

\end_inset

Range
\family default
 member variable (method 
\family typewriter
set
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
-
\end_layout

\end_inset

Default
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
-
\end_layout

\end_inset

Range
\family default
) in your constructor, you can easily define a symmetric range 
\begin_inset Formula $[-dR,\; dR]^{n}$
\end_inset

.
 If you need a different range definition, you may overload the methods
 
\family typewriter
getRangeLowerBound(int dim)
\family default
 and 
\family typewriter
getRangeUpperBound(int dim)
\family default
 which are to return the upper or lower range limit for a given dimension.
\begin_inset Note Comment
status open

\begin_layout Standard
template? noise?
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
The 
\family typewriter
AbstractProblemDouble
\family default
 class also contains a noise parameter and an individual template.
 The 
\emph on
noise
\emph default
 can be used to add gaussian fluctuation to any target function.
 If 
\emph on
noise
\emph default
 > 0, it defines the standard deviation of the random disturbance of 
\begin_inset Formula $f_{\mathrm{target}}(x)$
\end_inset

.
 The individual template defines the data representation for potential solutions.
 It also contains evolutionary operators which work directly on the representati
on, see Sec.
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{sub:Setting-Evolutionary-Operators}

\end_inset

 for a usage example.
\end_layout

\begin_layout Standard
We will now give short comments on further important member functions:
\end_layout

\begin_layout Description

\family typewriter
public
\begin_inset ERT
status collapsed

\begin_layout Standard

 ~
\end_layout

\end_inset

Object
\begin_inset ERT
status collapsed

\begin_layout Standard

 ~
\end_layout

\end_inset

clone()
\family default
 Object copy operator.
 We recommend implementing a copy constructor 
\family typewriter
public YourProblem(YourProblem o)
\family default
 and refering to it from within the 
\family typewriter
clone()
\family default
 method.
 You may call 
\family typewriter
cloneObjects
\family default
 from AbstractProblemDouble to copy the super members.
 Make sure that the copy constructor copies all necessary member variables
 you added to your class.
\end_layout

\begin_layout Description

\family typewriter
public
\begin_inset ERT
status collapsed

\begin_layout Standard

 ~
\end_layout

\end_inset

void
\begin_inset ERT
status collapsed

\begin_layout Standard

 ~
\end_layout

\end_inset

evaluate(AbstractEAIndividual
\begin_inset ERT
status collapsed

\begin_layout Standard

 ~
\end_layout

\end_inset

individual)
\family default
 Main evaluation method.
 We recommend not to override it.
\end_layout

\begin_layout Description

\family typewriter
public
\begin_inset ERT
status collapsed

\begin_layout Standard

 ~
\end_layout

\end_inset

abstract
\begin_inset ERT
status collapsed

\begin_layout Standard

 ~
\end_layout

\end_inset

double[]
\begin_inset ERT
status collapsed

\begin_layout Standard

 ~
\end_layout

\end_inset

eval(double[]
\begin_inset ERT
status collapsed

\begin_layout Standard

 ~
\end_layout

\end_inset

x)
\family default
 Essential evaluation method.
 Override it to implement the desired target function 
\begin_inset Formula $f_{target}(x)$
\end_inset

.
 Make sure that the delivered solution vector is always of the same dimensionali
ty 
\begin_inset Formula $m$
\end_inset

.
 Even if your problem is one-dimensional, return an array of length 1 with
 the single fitness value as the only field.
\end_layout

\begin_layout Description

\family typewriter
public
\begin_inset ERT
status collapsed

\begin_layout Standard

 ~
\end_layout

\end_inset

abstract
\begin_inset ERT
status collapsed

\begin_layout Standard

 ~
\end_layout

\end_inset

int
\begin_inset ERT
status collapsed

\begin_layout Standard

 ~
\end_layout

\end_inset

getProblemDimension()
\family default
 Return the problem dimension in solution space.
 Make sure it is constantly equal to 
\begin_inset Formula $n$
\end_inset

 during an optimization run.
 If you implement a corresponding method 
\family typewriter
public void setProblemDimension(int n)
\family default
 and define your class within the same package, you may change the dimension
 through the GUI.
\end_layout

\begin_layout Description

\family typewriter
public
\begin_inset ERT
status collapsed

\begin_layout Standard

 ~
\end_layout

\end_inset

void
\begin_inset ERT
status collapsed

\begin_layout Standard

 ~
\end_layout

\end_inset

initProblem()
\family default
 Called before optimization in general.
 If you define member variables of your class which are not constant, we
 recommend setting them to initial values in this function.
 If you override, make sure you call the super-method from within your version.
\end_layout

\begin_layout Description

\family typewriter
public
\begin_inset ERT
status collapsed

\begin_layout Standard

 ~
\end_layout

\end_inset

void
\begin_inset ERT
status collapsed

\begin_layout Standard

 ~
\end_layout

\end_inset

initPopulation(Population
\begin_inset ERT
status collapsed

\begin_layout Standard

 ~
\end_layout

\end_inset

population)
\family default
 This method is called before optimization with a certain population.
 It initializes the population to the problem specific range using the individua
l template and calls a method of the 
\family typewriter
Population
\family default
 collection to initialize the individuals randomly whithin the range.
 If you want to alter the way the individuals are initialized, we recommend
 overriding this method.
 Call the super-method from your implementation and make changes to the
 individuals afterwards.
\end_layout

\begin_layout Standard
For an example on how to extend 
\family typewriter
AbstractProblemDouble
\family default
 you can look at the 
\family typewriter
F1Problem
\family default
 class which implements a simple parabola function.
\end_layout

\begin_layout Paragraph*
The class 
\family typewriter
AbstractProblemBinary
\end_layout

\begin_layout Standard
The binary variant is widely analogous to 
\family typewriter
AbstractProblemDouble
\family default
.
 The main differences are that there is no range definition (the range is
 always 
\begin_inset Formula $0^{n}-1^{n}$
\end_inset

) and that the template is of a different type, namely 
\family typewriter
GAIndividualBinaryData
\family default
, and delivers a Java 
\family typewriter
BitSet
\family default
 as data representation instead of a double vector.
 The 
\family typewriter
eval
\family default
 function signature changes accordingly, and to implement a target function
 
\begin_inset Formula $g_{\mathrm{target}}(x)=y$
\end_inset

 with 
\begin_inset Formula $g_{\mathrm{target}}:\;\{0,1\}^{n}\rightarrow R^{m}$
\end_inset

, you need to work on a 
\family typewriter
BitSet
\family default

\begin_inset Foot
status collapsed

\begin_layout Standard
Concerning 
\family typewriter
BitSet
\family default
: it may be valuable to note that when looping over a 
\family typewriter
BitSet
\family default
, it is preferable to use the self defined problem dimension as index limit
 instead of 
\family typewriter
size()
\family default
 or 
\family typewriter
length()
\family default
 methods of 
\family typewriter
BitSet
\family default
.
\end_layout

\end_inset

 object.
\end_layout

\begin_layout Description

\family typewriter
public
\begin_inset ERT
status collapsed

\begin_layout Standard

 ~
\end_layout

\end_inset

abstract
\begin_inset ERT
status open

\begin_layout Standard

 ~
\end_layout

\end_inset

double[]
\begin_inset ERT
status open

\begin_layout Standard

 ~
\end_layout

\end_inset

eval(BitSet
\begin_inset ERT
status open

\begin_layout Standard

 ~
\end_layout

\end_inset

bs)
\family default
 Essential evaluation method.
 Override it to implement the desired target function 
\begin_inset Formula $g_{\mathrm{target}}(b)$
\end_inset

.
 Make sure that the delivered solution vector is always of the same dimensionali
ty 
\begin_inset Formula $m$
\end_inset

.
 Even if your problem is only one-dimensional, return an array of length
 1 with the single fitness value as only field.
\end_layout

\begin_layout Standard
For an example on how to implement binary functions, look at the 
\family typewriter
B1Problem
\family default
 class which realizes a simple minimize bits problem.
\end_layout

\begin_layout Subsubsection
The 
\family typewriter
OptimizerFactory
\family default

\begin_inset LatexCommand \label{sub:The-OptimizerFactory}

\end_inset


\end_layout

\begin_layout Standard
To access default optimization algorithms easily, we have defined an 
\family typewriter
OptimizerFactory
\family default
 class.
 It allows to specify an optimization algorithm by an ID number and mainly
 takes a problem class and an optional output file as input.
 For example, if you have a double-valued problem class and just want to
 retrieve one solution, use the 
\family typewriter
optimizeToDouble(final int optType, AbstractOptimizationProblem problem,
 String outputFilePrefix)
\family default
 method, which returns the solution as a double vector.
 
\end_layout

\begin_layout Standard
Table 
\begin_inset LatexCommand \ref{tab:Overview-OptimizerFactory}

\end_inset

 gives an overview over the currently accessible optimization strategies.
 You may use 
\family typewriter
showOptimizers()
\family default
 to get a string with a summary of the implemented algorithms with ID associatio
ns.
 A short example is shown in Listing 
\begin_inset LatexCommand \ref{alg:OptFact-Usage-example}

\end_inset

, where PSO is used to optimize the simple hyper parabola (in 10 dimensions
 by default).
 The PSO with 
\begin_inset Formula $50,000$
\end_inset

 evaluations should find a solution very close to zero, e.g.
 absolutely below 
\begin_inset Formula $10^{-30}{}{}$
\end_inset

 in every dimension.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
lstset{language=java, basicstyle=
\backslash
tiny, numbers=left, stepnumber=1, numbersep=5pt}
\end_layout

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\begin_layout Standard

import javaeva.OptimizerFactory;
\end_layout

\begin_layout Standard

import javaeva.server.go.problems.F1Problem;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

public class TestingF1PSO {
\end_layout

\begin_layout Standard

  public static void main(String[] args) {
\end_layout

\begin_layout Standard

    F1Problem f1 = new F1Problem(); 
\end_layout

\begin_layout Standard

    double[] sol;
\end_layout

\begin_layout Standard

    OptimizerFactory.setEvaluationTerminator(50000);
\end_layout

\begin_layout Standard

    sol = OptimizerFactory.optimizeToDouble(OptimizerFactory.PSO, f1, null);
\end_layout

\begin_layout Standard

    System.out.println("Found solution: ");
\end_layout

\begin_layout Standard

    for (int i=0; i<f1.getProblemDimension(); i++) System.out.print(sol[i]
 + " ");
\end_layout

\begin_layout Standard

    System.out.println();
\end_layout

\begin_layout Standard

  };
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard

%
\backslash
begin{algorithmic}  
\backslash
IF {$i
\backslash
geq maxval$}          
\backslash
STATE $i
\backslash
gets 0$ 
\backslash
ELSE         
\backslash
IF {$i+k
\backslash
leq maxval$}                 
\end_layout

\begin_layout Standard

%
\backslash
STATE $i
\backslash
gets i+k$          
\backslash
ENDIF 
\backslash
ENDIF  
\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Caption
Simple 
\family typewriter
OptimizerFactory
\family default
 usage example.
\begin_inset LatexCommand \label{alg:OptFact-Usage-example}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features>
<column alignment="left" valignment="top" leftline="true" width="0">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Short Description
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
STD_ES
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
A standard (15,50)-Evolution Strategy.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
CMA_ES
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(15,50)-Evolution Strategy with Covariance Matrix Adaptation.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
STD_GA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Standard Genetic Algorithm with elitism
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
PSO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Particle Swarm Optimization with constriction.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
DE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Differential Evolution
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
TRIBES
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Tribes: an adaptive PSO
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RANDOM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Random search (Monte-Carlo)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
HILLCL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Multi-start hill climbing
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
CL_HILLCL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Clustering multi-start hill climbing
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
CBN_ES
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Clustering-based Niching ES
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Caption
Overview over algorithms accessible through OptimizerFactory.
\begin_inset LatexCommand \label{tab:Overview-OptimizerFactory}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Termination Criteria
\begin_inset LatexCommand \label{sub:Termination-Criteria}

\end_inset


\end_layout

\begin_layout Standard
To configure the termination criteria of an optimization process started
 through the OptimizerFactory, use the setTerminator family.
 The default terminator stops at a maximal number of fitness evaluations,
 e.g.
 
\begin_inset Formula $10,000$
\end_inset

.
 To change the number of evaluations performed to, for example, 
\begin_inset Formula $50,000$
\end_inset

, call 
\family typewriter
OptimizerFactory.setEvaluationTerminator(50000) 
\family default
before starting the optimization, as in Alg.
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{alg:OptFact-Usage-example}

\end_inset

.
\end_layout

\begin_layout Standard
For more flexible termination criteria, there are several Terminator parameter
 classes you can use and set them directly using 
\family typewriter
OptimizerFactory.setTerminator(term)
\family default
.
 Available are the following variants:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
EvaluationTerminator
\family default
: Construct with a maximal number of evaluations.
 Constructor parameters:
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
maxEval
\family default
: integer number of evaluations to be performed at maximum.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
GenerationTerminator
\family default
: Terminate after a given number of generations.
 As not all algorithms use constant population sizes, we suggest to use
 EvaluationTerminator preferably.
 Constructor parameters:
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
gens
\family default
: integer number of generations to be performed at maximum.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
FitnessValueTerminator
\family default
: A minimum fitness value (vector) must be reached to terminate.
 Construct with a double array representing the target fitness value.
 Constructor parameters:
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
v
\family default
: double array fitness vector to be reached.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
FitnessConvergenceTerminator
\family default
: Terminate as soon as there is hardly any improvement in fitness for a
 certain period of time (
\emph on
stagnation
\emph default
 
\emph on
period
\emph default
), defined by a number of evaluations or generations.
 
\begin_inset Quotes eld
\end_inset

Hardly any improvement
\begin_inset Quotes erd
\end_inset

 is defined by a threshold 
\emph on
th
\emph default
, which can be set as absolute or relative threshold.
 In the absolute case, termination occurs if the best fitness changes less
 than 
\emph on
th
\emph default
 for a stagnation period 
\emph on
p
\emph default
, meaning 
\begin_inset Formula $\forall\, i\in\{0,1,...p-1\}:|f(x_{t-i}^{*})-f(x_{t-p}^{*})|<th$
\end_inset

, where 
\begin_inset Formula $f(x)$
\end_inset

 stands for the fitness at position 
\begin_inset Formula $x$
\end_inset

, while 
\begin_inset Formula $x_{t}^{*}$
\end_inset

 is the best solution found in iteration 
\begin_inset Formula $t$
\end_inset

.
 In the relative case, termination occurs if the fitness changes less than
 a certain percentage for a stagnation period, meaning 
\begin_inset Formula $\forall\, i\in\{0,1,..,p-1\}:|f(x_{t-i}^{*})-f(x_{t-p}^{*})|<|f(x_{t-p}^{*})|\cdot th$
\end_inset

.
 Constructor parameters:
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
thresh
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
: double valued fitness threshold 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\noun default
th.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
stagnPeriod
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
: integer length of the stagnation period.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
bFitCallBased
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
: boolean flag indicating evaluation-based or generation-based stagnation
 period.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
bAbsolute
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
: boolean flag  indicating absolute or relative 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\noun default
th.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
PhenotypeConvergenceTerminator
\family default
: In analogy to the 
\family typewriter
FitnessConvergenceTerminator
\family default
, terminate as soon as there is hardly any change in the best phenotype,
 meaning that 
\begin_inset Formula $\forall\, i\in\{0,1,...p-1\}:|x_{t-i}^{*}-x_{t-p}^{*}|<th$
\end_inset

 for the absolute case and 
\begin_inset Formula $\forall\, i\in\{0,1,..,p-1\}:|x_{t-i}^{*}-x_{t-p}^{*}|<|x_{t-p}^{*}|\cdot th$
\end_inset

 in the relative case.
 Constructor parameters:
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
thresh
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
: double valued phenotype norm threshold 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\noun default
th.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
stagnPeriod
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
: integer length of the stagnation period.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
bFitCallBased
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
: boolean flag indicating evaluation-based or generation-based stagnation
 period.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
bAbsolute
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
: boolean flag  indicating absolute or relative 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\noun default
th.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
CombinedTerminator
\family default
: For effective optimization, one might want to combine several criteria
 in a boolean way, i.e.
 terminate if 
\begin_inset Formula $20,000$
\end_inset

 evaluations have been performed OR the best fitness doesn't change for
 
\begin_inset Formula $1,000$
\end_inset

 evaluations.
 To allow for this, we provide the 
\family typewriter
CombinedTerminator
\family default
 class which just takes to terminator instances and combines them logically.
 Thus, terminators can be nested as required.
 Constructor parameters:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
t1
\family default
: First terminator to combine.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
t2
\family default
: Second terminator to combine.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
bAnd
\family default
: Boolean flag indicating whether to use conjunctive (AND, for bAnd == true)
 or disjunctive (OR, for bAnd == false) combination.
\end_layout

\end_deeper
\begin_layout Standard
Notes on terminators: 
\end_layout

\begin_layout Itemize
Note that the termination criterion is always checked after one iteration,
 i.e.
 one generation.
 This means that, if the number of evaluations is not a multiple of the
 population size or the population size is variable, the maximum number
 of evaluations may be slightly exceeded.
 The same holds for the stagnation time in convergence terminators.
\end_layout

\begin_layout Itemize
Concerning convergence terminators: Note that for flat plateaus in fitness
 space, the fitness may hardly change while there is still progress in the
 solution space.
 On the other hand, note that highly nonlinear problems may hardly change
 in phenotype but still change considerably in fitness.
 When using convergence terminators, we suggest to set the stagnation period
 sufficiently high.
\end_layout

\begin_layout Standard
For a usage example that creates and sets a terminator which stops if either
 
\begin_inset Formula $20,000$
\end_inset

 evaluations have been performed or both best fitness and phenotype converged
 for 
\begin_inset Formula $1,000$
\end_inset

 evaluations, see Listing
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{alg:Comb-terminator}

\end_inset

.
 After a combined termination, one might want to know why the run actually
 stopped.
 The method 
\family typewriter
terminatedBecause()
\family default
 implemented in 
\family typewriter
OptimizerFactory
\family default
 as well as any terminator object will return a String object describing
 the exact reason, while the method 
\family typewriter
lastEvalsPerformed()
\family default
 informs on how many evaluations were required.
 The PSO in the given example should require about 
\begin_inset Formula $5,000-7,000$
\end_inset

 evaluations to meet the two convergence criteria.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
lstset{language=java, basicstyle=
\backslash
tiny, numbers=left, stepnumber=1, numbersep=5pt}
\end_layout

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\begin_layout Standard

import javaeva.OptimizerFactory;
\end_layout

\begin_layout Standard

import javaeva.server.go.problems.F1Problem;
\end_layout

\begin_layout Standard

import javaeva.server.go.operators.terminators.*;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

public class TestingTerminators {
\end_layout

\begin_layout Standard

  public static void main(String[] args) {
\end_layout

\begin_layout Standard

    F1Problem f1 = new F1Problem(); 
\end_layout

\begin_layout Standard

    double[] sol;
\end_layout

\begin_layout Standard

    // A combined terminator for fitness and phenotype convergence
\end_layout

\begin_layout Standard

    CombinedTerminator convT = new CombinedTerminator(
\end_layout

\begin_layout Standard

            // fitness-based stagnation period, absolute threshold
\end_layout

\begin_layout Standard

            new FitnessConvergenceTerminator(0.0001, 1000, true, true),
\end_layout

\begin_layout Standard

            new PhenotypeConvergenceTerminator(0.0001, 1000, true, true),
\end_layout

\begin_layout Standard

            CombinedTerminator.AND);
\end_layout

\begin_layout Standard

    // Adding an evaluation terminator with OR to the convergence criterion
\end_layout

\begin_layout Standard

    OptimizerFactory.setTerminator(new CombinedTerminator(
\end_layout

\begin_layout Standard

              new EvaluationTerminator(20000),
\end_layout

\begin_layout Standard

              convT,
\end_layout

\begin_layout Standard

              CombinedTerminator.OR));
\end_layout

\begin_layout Standard

    sol = OptimizerFactory.optimizeToDouble(OptimizerFactory.PSO, f1, null);
\end_layout

\begin_layout Standard

    System.out.println(OptimizerFactory.terminatedBecause());
\end_layout

\begin_layout Standard

    System.out.println(OptimizerFactory.lastEvalsPerformed() 
\end_layout

\begin_layout Standard

                             + " evals performed, found solution: "
\end_layout

\begin_layout Standard

                             + OptimizerFactory.terminatedBecause()
\end_layout

\begin_layout Standard

                             + " Found solution: ");
\end_layout

\begin_layout Standard

    for (int i=0; i<f1.getProblemDimension(); i++) System.out.print(sol[i]
 + " ");
\end_layout

\begin_layout Standard

    System.out.println();
\end_layout

\begin_layout Standard

  };
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Caption
Terminator combination example.
\begin_inset LatexCommand \label{alg:Comb-terminator}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Customizing the Optimization
\end_layout

\begin_layout Standard
Beyond standard optimizers, you may wish to customize optimization parameters
 manually or iterate over different settings in a loop.
 To do this, you need to access the optimization parameter structure 
\family typewriter
GOParameters
\family default
 and alter its values before starting optimization.
 A 
\family typewriter
GOParameters
\family default
 instance contains all settings required for an optimization run: target
 function, optimizer, random seed, post-processing options and termination
 criterion; basically all that is also set through the workbench window
 of the GUI (Sec.
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{sub:The-Workbench-Window}

\end_inset

).
 To alter specific settings, it is sufficient to alter a 
\family typewriter
GOParameters
\family default
 instance generated by the 
\family typewriter
OptimizerFactory
\family default
 and then start the optimization using this altered parameter instance.
\end_layout

\begin_layout Subsubsection
Accessing Parameters
\end_layout

\begin_layout Standard
Look at Listing 
\begin_inset LatexCommand \ref{alg:Customizing-optimization.}

\end_inset

 for an example on how to customize optimization parameters.
 To find out about which operators are implemented and usable, it is again
 easiest to check out in the GUI, where there are also short descriptions
 available.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
lstset{language=java, basicstyle=
\backslash
tiny, numbers=left, stepnumber=1, numbersep=5pt}
\end_layout

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\begin_layout Standard

import java.util.BitSet;
\end_layout

\begin_layout Standard

import javaeva.server.go.operators.selection.SelectXProbRouletteWheel;
\end_layout

\begin_layout Standard

import javaeva.server.go.operators.terminators.EvaluationTerminator;
\end_layout

\begin_layout Standard

import javaeva.server.go.populations.Population;
\end_layout

\begin_layout Standard

import javaeva.server.go.problems.B1Problem;
\end_layout

\begin_layout Standard

import javaeva.server.go.strategies.GeneticAlgorithm;
\end_layout

\begin_layout Standard

import javaeva.server.modules.GOParameters;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

public class TestingGAB1 {
\end_layout

\begin_layout Standard

  public static void main(String[] args) {
\end_layout

\begin_layout Standard

    B1Problem b1 = new B1Problem();
\end_layout

\begin_layout Standard

    BitSet sol;
\end_layout

\begin_layout Standard

    // default go-parameter instance with a GA
\end_layout

\begin_layout Standard

    GOParameters gaParams = OptimizerFactory.standardGA(b1);            
    
\end_layout

\begin_layout Standard

    // add an evaluation terminator
\end_layout

\begin_layout Standard

    gaParams.setTerminator(new EvaluationTerminator(1000));
\end_layout

\begin_layout Standard

    // set a specific random seed
\end_layout

\begin_layout Standard

    gaParams.setSeed(2342);
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

    // access the GA
\end_layout

\begin_layout Standard

    GeneticAlgorithm ga = (GeneticAlgorithm)gaParams.getOptimizer();
\end_layout

\begin_layout Standard

    // set no elitism
\end_layout

\begin_layout Standard

    ga.setElitism(false);
\end_layout

\begin_layout Standard

    // set roulette wheel selection
\end_layout

\begin_layout Standard

    ga.setParentSelection(new SelectXProbRouletteWheel());
\end_layout

\begin_layout Standard

    // set population size 150
\end_layout

\begin_layout Standard

    ga.setPopulation(new Population(150));
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

    // run optimization and print intermediate results to a file with given
 prefix
\end_layout

\begin_layout Standard

    sol = OptimizerFactory.optimizeToBinary(gaParams, "ga-opt-results");
\end_layout

\begin_layout Standard

    System.out.println("Found solution: ");
\end_layout

\begin_layout Standard

    for (int i=0; i<b1.getProblemDimension(); i++) System.out.print(sol.get(i)+"
 ");
\end_layout

\begin_layout Standard

    System.out.println();
\end_layout

\begin_layout Standard

  };
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Caption
Customized optimization example.
\begin_inset LatexCommand \label{alg:Customizing-optimization.}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that in example 
\begin_inset LatexCommand \ref{alg:Customizing-optimization.}

\end_inset

, there will actually be 
\begin_inset Formula $1,050$
\end_inset

 evaluations performed, which is the first multiple of the population size
 of 150 that exceeds the maximum evaluation limit of 
\begin_inset Formula $1,000$
\end_inset

 set.
 To change the population size before a run, simply set a new population
 of the target size.
 Any population will be initialized to contain the given number of individuals
 by the problem class, usually in a random distribution over the problem
 range.
\end_layout

\begin_layout Subsubsection
Setting Evolutionary Operators
\begin_inset LatexCommand \label{sub:Setting-Evolutionary-Operators}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
lstset{language=java, basicstyle=
\backslash
tiny, numbers=left, stepnumber=1, numbersep=5pt}
\end_layout

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\begin_layout Standard

import javaeva.OptimizerFactory;
\end_layout

\begin_layout Standard

import javaeva.server.go.individuals.AbstractEAIndividual; 
\end_layout

\begin_layout Standard

import javaeva.server.go.operators.crossover.CrossoverESDefault; 
\end_layout

\begin_layout Standard

import javaeva.server.go.operators.mutation.MutateESCovarianceMartixAdaption;
 
\end_layout

\begin_layout Standard

import javaeva.server.go.operators.terminators.EvaluationTerminator; 
\end_layout

\begin_layout Standard

import javaeva.server.go.problems.FM0Problem; 
\end_layout

\begin_layout Standard

import javaeva.server.go.strategies.EvolutionStrategies; 
\end_layout

\begin_layout Standard

import javaeva.server.modules.GOParameters;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

public class TestingPlusCMAES {
\end_layout

\begin_layout Standard

  public static void main(String[] args) {
\end_layout

\begin_layout Standard

    // a simple bimodal target function, two optima
\end_layout

\begin_layout Standard

    FM0Problem fm0 = new FM0Problem();              
\end_layout

\begin_layout Standard

    AbstractEAIndividual bestIndy;          
\end_layout

\begin_layout Standard

    // create standard ES parameters                
\end_layout

\begin_layout Standard

    GOParameters esParams = OptimizerFactory.standardES(fm0);           
    
\end_layout

\begin_layout Standard

    esParams.setTerminator(new EvaluationTerminator(2000));             
    
\end_layout

\begin_layout Standard

    // set a random seed based on system time               
\end_layout

\begin_layout Standard

    esParams.setSeed(0);
\end_layout

\begin_layout Standard

                
\end_layout

\begin_layout Standard

    // set evolutionary operators and probabilities                 
\end_layout

\begin_layout Standard

    AbstractEAIndividual.setOperators(                              
\end_layout

\begin_layout Standard

                     fm0.getIndividualTemplate(),                       
     
\end_layout

\begin_layout Standard

                     new MutateESCovarianceMartixAdaption(), 0.9,       
                     
\end_layout

\begin_layout Standard

                     new CrossoverESDefault(), 0.1);         
\end_layout

\begin_layout Standard

                
\end_layout

\begin_layout Standard

    // access the ES                
\end_layout

\begin_layout Standard

    EvolutionStrategies es = (EvolutionStrategies)esParams.getOptimizer();
          
\end_layout

\begin_layout Standard

    // set a (1+5) selection strategy               
\end_layout

\begin_layout Standard

    es.setMu(1);            
\end_layout

\begin_layout Standard

    es.setLambda(5);                
\end_layout

\begin_layout Standard

    es.setPlusStrategy(true);       
\end_layout

\begin_layout Standard

                
\end_layout

\begin_layout Standard

    // run optimization and retrieve winner individual              
\end_layout

\begin_layout Standard

    bestIndy = (AbstractEAIndividual)OptimizerFactory.optimizeToInd(esParams,
 null);    
\end_layout

\begin_layout Standard

    System.out.println("Found solution: " 
\end_layout

\begin_layout Standard

                     + AbstractEAIndividual.getDefaultDataString(bestIndy));
\end_layout

\begin_layout Standard

  };
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Caption
Setting up a (1+5) CMA-ES.
\begin_inset LatexCommand \label{alg:(1+5)-CMA-ES.}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Listing
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{alg:(1+5)-CMA-ES.}

\end_inset

, a (1+5) CMA-ES is configured and run on a simple bimodal target function
 with the global optimum near (1.7/0) and a local one near (-1.44/0).
 The (1+5)-CMA-ES is powerful and will find the global optimum most of the
 time.
 Sometimes, however, due to its relatively high selection pressure and elitistic
 strategy, it will converge in the local optimum, depending on the random
 initialization.
\end_layout

\begin_layout Standard
Lines 20-23 of Listing
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{alg:(1+5)-CMA-ES.}

\end_inset

 show how to access evolutionary operators directly.
 What happens here is that the template individual delivered with the problem
 class (because the problem defines the representation) is modified to use
 the given mutation and crossover operator and probabilities.
 Typical for ES, the mutation probability 
\begin_inset Formula $p_{m}$
\end_inset

 is relatively high, while the crossover probability 
\begin_inset Formula $p_{C}$
\end_inset

 is rather low.
 One could also use 
\family typewriter
fm0.getIndividualTemplate().setMutationOperator(...)
\family default
 etc.
 to set the operators and probabilities one by one just as through the GUI.
 Notice that not all implemented heuristics make use of individual evolutionary
 operators.
 Several come with their own operator definitions, such as DE and PSO, for
 example.
 The Hill Climbers, on the other hand, do use individual mutation but override
 individual probabilities to 
\begin_inset Formula $p_{m}=1$
\end_inset

 and 
\begin_inset Formula $p_{c}=0$
\end_inset

 by definition.
\end_layout

\begin_layout Subsubsection
A Multi-Modal Example with Post-Processing
\begin_inset LatexCommand \label{sub:A-Multi-Modal-Example}

\end_inset


\end_layout

\begin_layout Standard
When looking at the last example in 
\begin_inset LatexCommand \ref{sub:Setting-Evolutionary-Operators}

\end_inset

 working on a bimodal function, one might ask how to retrieve more than
 just one optimum of the target function.
 In 
\noun on
JavaEvA
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
 there are some optimizers implemented which are specialized on this task.
 Listing
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{alg:CBN-pp}

\end_inset

 shows an example using the clustering-based niching EA (CBN-EA) 
\begin_inset LatexCommand \cite{streichertClustering03}

\end_inset

 and post-processing to identify both optima of the target function.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
lstset{language=java, basicstyle=
\backslash
tiny, numbers=left, stepnumber=1, numbersep=5pt}
\end_layout

\begin_layout Standard


\backslash
begin{lstlisting}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

import java.util.Vector;
\end_layout

\begin_layout Standard

import javaeva.OptimizerFactory;
\end_layout

\begin_layout Standard

import javaeva.server.go.individuals.AbstractEAIndividual; 
\end_layout

\begin_layout Standard

import javaeva.server.go.operators.postprocess.PostProcessParams; 
\end_layout

\begin_layout Standard

import javaeva.server.go.operators.terminators.EvaluationTerminator; 
\end_layout

\begin_layout Standard

import javaeva.server.go.problems.FM0Problem; 
\end_layout

\begin_layout Standard

import javaeva.server.modules.GOParameters;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

public class TestingCBNPostProc {
\end_layout

\begin_layout Standard

  public static void main(String[] args) {
\end_layout

\begin_layout Standard

    FM0Problem fm0 = new FM0Problem();              
\end_layout

\begin_layout Standard

    AbstractEAIndividual best;              
\end_layout

\begin_layout Standard

    Vector<AbstractEAIndividual> ppSols;
\end_layout

\begin_layout Standard

                
\end_layout

\begin_layout Standard

    GOParameters esParams = OptimizerFactory.cbnES(fm0);            
\end_layout

\begin_layout Standard

    esParams.setTerminator(new EvaluationTerminator(2000));             
    
\end_layout

\begin_layout Standard

    esParams.setSeed(0);
\end_layout

\begin_layout Standard

                
\end_layout

\begin_layout Standard

    best = (AbstractEAIndividual)OptimizerFactory.optimizeToInd(esParams,
 null);
\end_layout

\begin_layout Standard

                
\end_layout

\begin_layout Standard

    System.out.println("Found solution: "                           
\end_layout

\begin_layout Standard

                + AbstractEAIndividual.getDefaultDataString(best));     
\end_layout

\begin_layout Standard

                
\end_layout

\begin_layout Standard

    // post-process with clustering only            
\end_layout

\begin_layout Standard

    ppSols = OptimizerFactory.postProcessIndVec(new PostProcessParams(0,
 0.1, 5));          
\end_layout

\begin_layout Standard

    System.out.println("After clustering: ");               
\end_layout

\begin_layout Standard

    for (AbstractEAIndividual indy : ppSols) {                      
\end_layout

\begin_layout Standard

      System.out.println(AbstractEAIndividual.getDefaultDataString(indy));
            
\end_layout

\begin_layout Standard

    }       
\end_layout

\begin_layout Standard

                
\end_layout

\begin_layout Standard

    // post-process with clustering and hill climbing               
\end_layout

\begin_layout Standard

    ppSols = OptimizerFactory.postProcessIndVec(new PostProcessParams(1000,
 0.1, 5));               
\end_layout

\begin_layout Standard

    System.out.println("After clustering / HC: ");          
\end_layout

\begin_layout Standard

    for (AbstractEAIndividual indy : ppSols) {                      
\end_layout

\begin_layout Standard

      System.out.println(AbstractEAIndividual.getDefaultDataString(indy));
            
\end_layout

\begin_layout Standard

    }
\end_layout

\begin_layout Standard

  };
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Caption
Solving a bimodal function with CBN and post-processing.
\begin_inset LatexCommand \label{alg:CBN-pp}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice that two post-processing cycles are performed (lines 26 and 33).
 Any repeated post-processing iteration performed on the 
\family typewriter
OptimizerFactory
\family default
 uses the same initial state.
 This means that if there is no new optimization cycle, any new post-processing
 will work on the same set of solutions, namely the result population of
 the last optimization.
\end_layout

\begin_layout Standard
This is useful, for example, to search for optima using different resolutions
 iteratively.
 In our example, we however just demonstrate the different results without
 (line 26) and with clustering (line 33).
 If you run the example a few times, it will happen quite often that after
 the first post-processing with clustering only, more than the two optima
 are returned, while after the second step with hill climbing, this will
 happen rather seldomly.
 All in all, CBN locates the two optima in most of the cases and post-processing
 helps to identify the real hot spot.
 In Fig.
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{fig:Exemplary-states-of-CBN}

\end_inset

, two graphs show the target function and the states of an exemplary CBN-run
 after 500 (left) and 1,500 evaluations (right).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename /afs/cs.uni-tuebingen.de/home/mkron/workspace/JE2Base/doc/pics/fm0-cbn-500.jpg
	lyxscale 70
	width 49col%

\end_inset


\begin_inset Graphics
	filename /afs/cs.uni-tuebingen.de/home/mkron/workspace/JE2Base/doc/pics/fm0-cbn-1500.jpg
	lyxscale 70
	width 49col%

\end_inset


\end_layout

\begin_layout Caption
Exemplary states of CBN on the simple bimodal FM0Problem.
\begin_inset LatexCommand \label{fig:Exemplary-states-of-CBN}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The FM0Problem is of course very simple, 2-dimensional and having only two
 optima in the defined range.
 For harder problems, a few thousand evaluations will not suffice, and for
 highly multi-modal target functions, e.g.
 if there are thousands or tens of thousands of local optima, things get
 really tough.
 The current implementation of CBN is able to find more optima than the
 population size defined, because it is able to reinitialize a converged
 cluster during a run, saving a representative to an archive.
 But for problems with a lot of deceptive optima, it might also be a good
 strategy to concentrate on finding one global optimum, and, as it won't
 be found in most of the runs, look at the results of the single-run solution
 set.
\end_layout

\begin_layout Section
Further Reading
\begin_inset LatexCommand \label{sec:Further-Reading}

\end_inset


\end_layout

\begin_layout Standard
As noted before, this introduction does not cover algorithmic basics.
 We recommend the introduction of Engelbrecht 
\begin_inset LatexCommand \cite{Engelbrecht07CI}

\end_inset

 for newer strategies (DE, PSO) and Bäck et al.
 
\begin_inset LatexCommand \cite{Baeck99EC1}

\end_inset

 for classical Evolutionary Algorithms.
 To go into details of 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
, a look on the technical report of 2005 
\begin_inset LatexCommand \cite{JOptDocumentation}

\end_inset

, though slightly outdated, will still be helpful, as well as the thesis
 of Felix Streichert 
\begin_inset LatexCommand \cite{Streichert07}

\end_inset

, one of the main authors of 
\noun on
JavaEvA
\noun default
.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Section
General Hints on Optimization with 
\noun on
JavaEvA 2
\end_layout

\begin_layout Standard
As you have come so far, you have hopefully learned a few things about the
 concepts of 
\noun on
JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2 
\noun default
and got an idea on how optimization in the framework can be done.
 Now we want to give a few more practical hints on what to do with an unknown,
 probably difficult function.
 Let's suppose you have a mathematical or algorithmic problem which is infeasibl
e to solve by means of mathematical analysis, gradients are not computable
 in a simple way, and you haven't found a specialized algorithm or heuristic
 in literature that solves it to the quality you need, or you have found
 one but you don't understand it and can't download it anywhere.
 All in all, you have a tough problem, 
\noun on
MyToughProblem
\noun default
, and you want to optimize it.
\end_layout

\begin_layout Standard
Let's also suppose you can implement 
\noun on
MyToughProblem
\noun default
 in Java (Sec.
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{sec:Quickly-Adding-Your-Problem}

\end_inset

) or make it accessible for
\noun on
 JavaEvA
\begin_inset ERT
status collapsed

\begin_layout Standard

~
\end_layout

\end_inset

2
\noun default
 through an external interface (Sec.
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{sec:External-Interfaces}

\end_inset

).
 
\end_layout

\begin_layout Standard
You might now be tempted to ask: 
\begin_inset Quotes eld
\end_inset

Exactly which optimizer do I need to run with which parameters to solve
 
\noun on
MyToughProblem
\noun default
 once and for all times?
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
And as you might have feared, this is a question which we cannot answer,
 and maybe noone else can.
 But we will at least try to come a bit closer to an answer here.
 There are several choices you have to make before optimization, one of
 the earliest concern implementation: which representation to use? E.g.
 in Sec.
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{sub:Accessing-Standard-Optimizers}

\end_inset

, we said a few things about double-valued and binary representation, and
 many problems are natural to the one or the other implementation.
 Combinatorical problems, for example, can be much easier projected to a
 binary vector than to a double-valued one.
 Continuous functions are a typical case for a real valued representation.
\end_layout

\begin_layout Itemize
which representation? 
\end_layout

\begin_layout Itemize
how many optima? 
\end_layout

\begin_layout Itemize
what range? 
\end_layout

\begin_layout Itemize
will specialized operators help?
\end_layout

\begin_layout Itemize
what about constraints?
\end_layout

\begin_layout Itemize
what about multi objectives?
\end_layout

\begin_layout Standard
read the examples given in Sec.
\begin_inset ERT
status open

\begin_layout Standard

~
\end_layout

\end_inset


\begin_inset LatexCommand \ref{sec:Using-the-API}

\end_inset

, you might So, for an unknown function
\end_layout

\begin_layout Standard
However, if you are dealing with an unknown function and you reckon that
 it has quite a lot of optima, 
\end_layout

\begin_layout Itemize
Which options can be changed at all for optimizer X? -> anhang with GOParameter
 classes? Some optimizers have no specialized GOParameters.
 Access optimizer directly.
\end_layout

\begin_layout Section
Optimization Context
\end_layout

\begin_layout Section
Architecture
\end_layout

\begin_layout Subsection
The JE2 Modules
\end_layout

\begin_layout Subsection
The Concepts
\end_layout

\begin_layout Subsection
The GUI Workbench
\end_layout

\begin_layout Subsection
The Configuration File
\end_layout

\begin_layout Section
Advanced Use Cases
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand \bibtex[plain]{/afs/cs.uni-tuebingen.de/home/mkron/workspace/JE2Base/doc/JE2DocCitations}

\end_inset


\end_layout

\end_body
\end_document
